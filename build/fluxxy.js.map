{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 70268f2ec189626dd023","webpack:///./index.js","webpack:///./lib/flux.js","webpack:///./lib/command_hub.js","webpack:///./lib/event_hub.js","webpack:///./lib/store_hub.js","webpack:///./lib/mixin.js","webpack:///./lib/event_collector.js","webpack:///./lib/store.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,yB;;;;;;ACzEA;;AAEA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;AC7DA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;ACjDA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;;AAEA,2B;;;;;;AC3CA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2B;;;;;;AClCA;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iC;;;;;;ACvBA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wB","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fluxxy\"] = factory();\n\telse\n\t\troot[\"Fluxxy\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 70268f2ec189626dd023\n **/","var Flux = require('./lib/flux'),\n    CommandHub = require('./lib/command_hub'),\n    EventHub = require('./lib/event_hub'),\n    StoreHub = require('./lib/store_hub');\n\nvar Fluxxy = function () {\n\n    /**\n     * Here all Fluxy logic happens, to couple Stores with React\n     * @type Flux\n     */\n    this.Flux = new Flux(this);\n\n    /**\n     * Place for events\n     * @type EventHub\n     */\n    this.EventHub = new EventHub();\n\n    /**\n     * Place for command collections\n     * @type CommandHub\n     */\n    this.CommandHub = new CommandHub(this.EventHub);\n\n    /**\n     * Place for stores\n     * @type {StoreHub}\n     */\n    this.StoreHub = new StoreHub(this.Flux, this.EventHub);\n\n    /**\n     * Set/get a commmand collection\n     * @param namespace\n     * @returns CommandCollection\n     */\n    this.command = function (namespace) {\n        if (typeof arguments[1] != 'undefined') {\n            this.CommandHub.register(namespace, arguments[1]);\n        }\n        return this.CommandHub.find(namespace);\n    };\n\n    /**\n     * Set/get a store\n     * @param namespace\n     * @returns Store\n     */\n    this.store = function (namespace) {\n        if (typeof arguments[1] != 'undefined') {\n            this.StoreHub.register(namespace, arguments[1]);\n        }\n        return this.StoreHub.find(namespace);\n    };\n\n    /**\n     * Get Fluxxy mixin\n     * @return FluxxyMixin\n     */\n    this.flux = function () {\n        return this.Flux;\n    };\n\n    /**\n     * Get mixin for watching a store\n     * @param stores\n     * @returns {*}\n     */\n    this.watch = function (stores) {\n        return this.Flux.watch(stores);\n    }\n};\n\nmodule.exports = Fluxxy;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","var Mixin = require('./mixin');\n\nvar Flux = function (fluxxy) {\n\n    /**\n     * Callbacks that listen to changes in stores\n     * @type {Array}\n     */\n    var storeCallbacks = [];\n\n    /**\n     * Register a new listener on a store\n     * @param store\n     * @param callback\n     * @param context\n     */\n    this.onStoreChange = function (store, callback, context) {\n        storeCallbacks.push({\n            store: store,\n            callback: callback,\n            context: context\n        });\n    };\n\n    /**\n     * Returns the Mixin that allows for watching\n     * @param stores\n     */\n    this.watch = function (stores) {\n        var mixin = new Mixin(fluxxy.flux(), stores);\n        mixin.stores = stores;\n        return mixin;\n    };\n\n    /**\n     * A notification about which store changed\n     * @param store\n     */\n    this._changed = function (store) {\n        for (var i in storeCallbacks) {\n            if (storeCallbacks[i].store == store) {\n                storeCallbacks[i].callback.apply(storeCallbacks[i].context);\n            }\n        }\n    };\n\n    /**\n     * Alias for fluxxy.store\n     */\n    this.store = function () {\n        return fluxxy.store(arguments[0], arguments[1]);\n    };\n\n    /**\n     * Alias for fluxxy.command\n     */\n    this.command = function () {\n        return fluxxy.command(arguments[0], arguments[1]);\n    };\n};\n\nmodule.exports = Flux;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/flux.js\n ** module id = 1\n ** module chunks = 0\n **/","var EventCollector = require('./event_collector');\n\nvar CommandHub = function (eventHub) {\n\n    /**\n     * List of all command collections\n     * @type Object\n     */\n    var commandCollections = {};\n\n    /**\n     * Create new event collector for a certain namespace\n     * @returns {EventCollector}\n     */\n    function getEventCollectorForNamespace(namespace) {\n        return new EventCollector(namespace, eventHub);\n    }\n\n    /**\n     * Initialize the passed command collection\n     * @param namespace\n     * @param commandCollection\n     * @returns CommandCollection\n     */\n    function initializeCommandCollection(namespace, commandCollection) {\n        var eventCollectorForNamespace = getEventCollectorForNamespace(namespace);\n        return new commandCollection(eventCollectorForNamespace);\n    }\n\n    /**\n     * Register a new command collection\n     * @param namespace\n     * @param commandCollection\n     */\n    this.register = function (namespace, commandCollection) {\n        commandCollections[namespace] = initializeCommandCollection(namespace, commandCollection);\n    };\n\n    /**\n     * Find a command collection\n     * @param namespace\n     * @return CommandCollection\n     * @throws error when command collection is not found\n     */\n    this.find = function (namespace) {\n        return commandCollections[namespace];\n    }\n};\n\nmodule.exports = CommandHub;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/command_hub.js\n ** module id = 2\n ** module chunks = 0\n **/","var EventHub = function () {\n\n    /**\n     * All callbacks\n     * @type {Array}\n     */\n    var callbacks = [];\n\n    /**\n     * Notify about an event\n     * @param namespace\n     * @param eventName\n     * @param data\n     */\n    this.dispatch = function (namespace, eventName, data) {\n        for (var i in callbacks) {\n            if (\n                callbacks[i].namespace == namespace\n                && callbacks[i].eventName == eventName\n            ) {\n                callbacks[i].callback.apply(callbacks[i].context, [data]);\n            }\n        }\n    };\n\n    /**\n     * Register a new callback\n     * @param namespace\n     * @param eventName\n     * @param callback\n     * @param context (optional)\n     */\n    this.on = function (namespace, eventName, callback) {\n        callbacks.push({\n            namespace: namespace,\n            eventName: eventName,\n            callback: callback,\n            context: typeof arguments[3] == 'undefined' ? callback : arguments[3]\n        });\n    }\n\n};\n\nmodule.exports = EventHub;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/event_hub.js\n ** module id = 3\n ** module chunks = 0\n **/","var Store = require('./store');\n\nvar StoreHub = function (flux, eventHub) {\n\n    var stores = {};\n\n    function initializeStore(namespace, toBeAddedStore) {\n        var store = new Store(namespace, flux);\n        var initializedStore = new toBeAddedStore(store);\n        initializedStore.construct(eventHub);\n        return initializedStore;\n    }\n\n    /**\n     * Register a new store\n     * @param namespace\n     * @param store\n     */\n    this.register = function (namespace, store) {\n        stores[namespace] = initializeStore(namespace, store);\n    };\n\n    /**\n     * Find a store\n     * @param namespace\n     * @return Store\n     * @throws error when command collection is not found\n     */\n    this.find = function (namespace) {\n        return stores[namespace];\n    }\n\n};\n\nmodule.exports = StoreHub;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/store_hub.js\n ** module id = 4\n ** module chunks = 0\n **/","var Mixin = function (flux, stores) {\n    return {\n\n        /**\n         * Initial state from the store\n         * @returns {*}\n         */\n        getInitialState: function () {\n            return this.getStoreState();\n        },\n\n        /**\n         * When a component is mounted register\n         */\n        componentDidMount: function () {\n            for (var i in stores) {\n                flux.onStoreChange(stores[i], function () {\n                    this.setState(this.getStoreState());\n                }.bind(this));\n            }\n        },\n\n        /**\n         * When store updates we also make sure the latest state is passed\n         */\n        componentWillReceiveProps: function () {\n            this.setState(this.getStoreState());\n        }\n    }\n};\n\nmodule.exports = Mixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/mixin.js\n ** module id = 5\n ** module chunks = 0\n **/","var EventCollector = function (namespace, eventHub) {\n\n    /**\n     * Notify the event collector something happened\n     * @param eventName\n     * @param data\n     */\n    this.dispatch = function (eventName, data) {\n        eventHub.dispatch(namespace, eventName, data);\n    };\n\n    /**\n     * Dispatch for a certain namespace, only for advanced implementations, normally your event collector\n     * is chosen specifically for you command collection\n     * @param namespace\n     * @param eventName\n     * @param data\n     */\n    this.dispatchForNamespace = function (namespace, eventName, data) {\n        eventHub.dispatch(namespace, eventName, data);\n    }\n};\n\nmodule.exports = EventCollector;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/event_collector.js\n ** module id = 6\n ** module chunks = 0\n **/","var Store = function (namespace, flux) {\n\n    /**\n     * Index of objects\n     * @type {Array}\n     */\n    var objects = [];\n\n    /**\n     * Add an object to the store\n     * @param obj\n     */\n    this.add = function (obj) {\n        objects.push(obj);\n    };\n\n    /**\n     * Fetch all objects in store\n     * @returns []\n     */\n    this.all = function () {\n        return objects;\n    };\n\n    /**\n     * Notify about change\n     */\n    this.changed = function () {\n        flux._changed(namespace);\n    }\n};\n\nmodule.exports = Store;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/store.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"fluxxy.js"}