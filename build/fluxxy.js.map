{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 744a79e1891b23ecd410","webpack:///./index.js","webpack:///./lib/flux.js","webpack:///./lib/command_hub.js","webpack:///./lib/event_hub.js","webpack:///./lib/store_hub.js","webpack:///./lib/mixin.js","webpack:///./lib/store.js","webpack:///./lib/event_collector.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yB;;;;;;ACpFA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;ACjDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;ACjDA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;;AAEA,2B;;;;;;ACvDA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2B;;;;;;ACtDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wB;;;;;;ACzFA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wB;;;;;;ACrHA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iC","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fluxxy\"] = factory();\n\telse\n\t\troot[\"Fluxxy\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 744a79e1891b23ecd410\n **/","var Flux = require('./lib/flux'),\n    CommandHub = require('./lib/command_hub'),\n    EventHub = require('./lib/event_hub'),\n    StoreHub = require('./lib/store_hub'),\n    Mixin = require('./lib/mixin');\n\nvar Fluxxy = function () {\n\n    /**\n     * Here all Fluxxy logic happens, to couple Stores with React\n     * @type Flux\n     */\n    this.Flux = new Flux(this);\n\n    /**\n     * Place for events\n     * @type EventHub\n     */\n    this.EventHub = new EventHub();\n\n    /**\n     * Place for command collections\n     * @type CommandHub\n     */\n    this.CommandHub = new CommandHub(this.EventHub);\n\n    /**\n     * Place for stores\n     * @type {StoreHub}\n     */\n    this.StoreHub = new StoreHub(this.Flux, this.EventHub);\n\n    /**\n     * Set/get a commmand collection\n     * @param namespace\n     * @returns CommandCollection\n     */\n    this.command = function (namespace) {\n        if (typeof arguments[1] != 'undefined') {\n            this.CommandHub.register(namespace, arguments[1]);\n        }\n        return this.CommandHub.find(namespace);\n    };\n\n    /**\n     * Set/get a store\n     * @param namespace\n     * @returns Store\n     */\n    this.store = function (namespace) {\n        if (typeof arguments[1] != 'undefined') {\n            this.StoreHub.register(namespace, arguments[1]);\n        }\n        return this.StoreHub.find(namespace);\n    };\n\n    /**\n     * Get Fluxxy mixin\n     * @return FluxxyMixin\n     */\n    this.flux = function () {\n        return this.Flux;\n    };\n\n};\n\n/**\n * Get mixin for watching a store\n * @param stores\n * @returns Mixin\n */\nFluxxy.watch = function (stores) {\n    var component = typeof arguments[1] != 'undefined' ? arguments[1] : null;\n    var mixin = new Mixin(stores, component);\n    mixin.construct();\n    return mixin;\n};\n\n/**\n * When implementing loading logic this is a helper string\n * @type string\n */\nFluxxy.LOADING = '*fluxxy-loading-tag*';\n\nmodule.exports = Fluxxy;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","var Flux = function (fluxxy) {\n\n    /**\n     * Callbacks that listen to changes in stores\n     * @type {Array}\n     */\n    var storeCallbacks = [];\n\n    /**\n     * Register a new listener on a store\n     * @param store\n     * @param callback\n     * @param context\n     */\n    this.onStoreChange = function (store, callback, context) {\n        storeCallbacks.push({\n            store: store,\n            callback: callback,\n            context: context\n        });\n    };\n\n    /**\n     * A notification about which store changed\n     * @param store\n     */\n    this._changed = function (store) {\n        for (var i in storeCallbacks) {\n            if (storeCallbacks[i].store == store) {\n                storeCallbacks[i].callback.apply(storeCallbacks[i].context);\n            }\n        }\n    };\n\n    /**\n     * Alias for fluxxy.store\n     */\n    this.store = function () {\n        return fluxxy.store(arguments[0], arguments[1]);\n    };\n\n    /**\n     * Alias for fluxxy.command\n     */\n    this.command = function () {\n        return fluxxy.command(arguments[0], arguments[1]);\n    };\n};\n\nmodule.exports = Flux;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/flux.js\n ** module id = 1\n ** module chunks = 0\n **/","var EventCollector = require('./event_collector');\n\nvar CommandHub = function (eventHub) {\n\n    /**\n     * List of all command collections\n     * @type Object\n     */\n    var commandCollections = {};\n\n    /**\n     * Create new event collector for a certain namespace\n     * @returns {EventCollector}\n     */\n    function getEventCollectorForNamespace(namespace) {\n        return new EventCollector(namespace, eventHub);\n    }\n\n    /**\n     * Initialize the passed command collection\n     * @param namespace\n     * @param commandCollection\n     * @returns CommandCollection\n     */\n    function initializeCommandCollection(namespace, commandCollection) {\n        var eventCollectorForNamespace = getEventCollectorForNamespace(namespace);\n        return new commandCollection(eventCollectorForNamespace);\n    }\n\n    /**\n     * Register a new command collection\n     * @param namespace\n     * @param commandCollection\n     */\n    this.register = function (namespace, commandCollection) {\n        commandCollections[namespace] = initializeCommandCollection(namespace, commandCollection);\n    };\n\n    /**\n     * Find a command collection\n     * @param namespace\n     * @return CommandCollection\n     * @throws error when command collection is not found\n     */\n    this.find = function (namespace) {\n        return commandCollections[namespace];\n    }\n};\n\nmodule.exports = CommandHub;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/command_hub.js\n ** module id = 2\n ** module chunks = 0\n **/","var EventHub = function () {\n\n    /**\n     * All callbacks\n     * @type {Array}\n     */\n    var callbacks = [];\n\n    /**\n     * If we're currently dispatching\n     * @type {boolean}\n     */\n    var dispatching = false;\n\n    /**\n     * Notify about an event\n     * @param namespace\n     * @param eventName\n     * @param data\n     */\n    this.dispatch = function (namespace, eventName, data) {\n        if (dispatching) {\n            console.error('You tried to dispatch ' + namespace + '.' + eventName + ' while we\\'re dispatching another event, this is not allowed');\n            return;\n        }\n        dispatching = true;\n        for (var i in callbacks) {\n            if (\n                callbacks[i].namespace == namespace\n                && callbacks[i].eventName == eventName\n            ) {\n                callbacks[i].callback.apply(callbacks[i].context, [data]);\n            }\n        }\n        dispatching = false;\n    };\n\n    /**\n     * Register a new callback\n     * @param namespace\n     * @param eventName\n     * @param callback\n     * @param context\n     */\n    this.on = function (namespace, eventName, callback, context) {\n        callbacks.push({\n            namespace: namespace,\n            eventName: eventName,\n            callback: callback,\n            context: context\n        });\n    }\n\n};\n\nmodule.exports = EventHub;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/event_hub.js\n ** module id = 3\n ** module chunks = 0\n **/","var Store = require('./store');\n\nvar StoreHub = function (flux, eventHub) {\n\n    var stores = {};\n\n    /**\n     * Initialize the to be added store\n     * @param namespace\n     * @param toBeAddedStore\n     * @returns toBeAddedStore\n     */\n    function initializeStore(namespace, toBeAddedStore) {\n        var events = new function () {\n            this.on = function (namespace, eventName, callback) {\n                eventHub.on(namespace, eventName, callback, initializedStore);\n            }\n        };\n\n        //Initialize a helper store\n        var store = new Store(namespace, flux);\n\n        //Initiate the to be added store\n        var initializedStore = new toBeAddedStore(store, events);\n\n        //Push a function that implements the `on` method, however will pass the store as context to the actual eventHub\n        if (typeof initializedStore.construct != 'undefined') {\n            initializedStore.construct(events);\n        }\n\n        return initializedStore;\n    }\n\n    /**\n     * Register a new store\n     * @param namespace\n     * @param store\n     */\n    this.register = function (namespace, store) {\n        stores[namespace] = initializeStore(namespace, store);\n    };\n\n    /**\n     * Find a store\n     * @param namespace\n     * @return Store\n     * @throws error when command collection is not found\n     */\n    this.find = function (namespace) {\n        return stores[namespace];\n    }\n\n};\n\nmodule.exports = StoreHub;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/store_hub.js\n ** module id = 4\n ** module chunks = 0\n **/","var Mixin = function (stores, component) {\n\n    return {\n\n        construct: function () {\n            if (component != null) {\n                component.state = this.getInitialState();\n                this._registerListenerWithComponent();\n            }\n        },\n\n        /**\n         * When we're in a traditional mixin, we can access the component through `this.getContext()` however, in ES6 the\n         * \"mixin\" is explicitly passed\n         */\n        getContext: function () {\n            return component != null ? component : this;\n        },\n\n        /**\n         * Get watched stores\n         * @returns array\n         */\n        getWatchedStores: function () {\n            return typeof stores == 'object' ? stores : [stores];\n        },\n\n        /**\n         * Get store state\n         * @param props\n         * @returns {}\n         * @private\n         */\n        _getStoreState: function (props) {\n            return typeof this.getContext().getStoreState != 'undefined' ? this.getContext().getStoreState(props) : {};\n        },\n\n        /**\n         * Initial state from the store\n         * @returns {*}\n         */\n        getInitialState: function () {\n            return this._getStoreState(this.getContext().props);\n        },\n\n        /**\n         * Get the flux instance\n         * @returns Flux\n         */\n        getFlux: function () {\n            return this.getContext().props.flux;\n        },\n\n        /**\n         * Touch the state\n         * @private\n         */\n        _touch: function () {\n            var props = this.getContext().props;\n            var state = this._getStoreState(props);\n            this.getContext().setState(state);\n        },\n\n        /**\n         * Will make sure that the component is listening on the store\n         * @private\n         */\n        _registerListenerWithComponent: function () {\n            this.getWatchedStores().forEach(function (store) {\n                this.getFlux().onStoreChange(store, this._touch.bind(this));\n            }.bind(this));\n        },\n\n        /**\n         * When a component is mounted register\n         */\n        componentDidMount: function () {\n            this._registerListenerWithComponent();\n        },\n\n        /**\n         * When store updates we also make sure the latest state is passed\n         */\n        componentWillReceiveProps: function (nextProps) {\n            this.getContext().setState(this._getStoreState(nextProps));\n        }\n    }\n};\n\nmodule.exports = Mixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/mixin.js\n ** module id = 5\n ** module chunks = 0\n **/","var Store = function (namespace, flux) {\n\n    /**\n     * Index of objects\n     * @type {Array}\n     */\n    var objects = [];\n\n    /**\n     * Key marking the index\n     * @type {string}\n     */\n    var indexKey = 'id';\n\n    /**\n     * Getter for namespace\n     * @returns string\n     */\n    this.namespace = function() {\n        return namespace;\n    };\n\n    /**\n     * Accessor for flux\n     * @returns Flux\n     */\n    this.flux = function() {\n        return flux;  \n    };\n\n    /**\n     * Set the key which marks the index of the objects\n     * @param key\n     */\n    this.setIndexKey = function (key) {\n        indexKey = key;\n    };\n\n    /**\n     * Add an object to the store\n     * @param obj\n     */\n    this.add = function (obj) {\n        objects.push(obj);\n    };\n\n    /**\n     * Fetch all objects in store\n     * @returns []\n     */\n    this.all = function () {\n        return objects;\n    };\n\n    /**\n     * Get number of objects in store\n     * @returns {Number}\n     */\n    this.size = function () {\n        return objects.length;\n    };\n\n    /**\n     * Find value by default key\n     * @param val\n     */\n    this.find = function (val) {\n        return this.findByKey(indexKey, val);\n    };\n\n    /**\n     *\n     * @param key\n     * @param val\n     * @returns {*}\n     */\n    this.findByKey = function (key, val) {\n        for (var i in objects) {\n            if (objects[i][key] == val) {\n                return objects[i];\n            }\n        }\n    };\n\n    /**\n     * Add or update an object\n     * @param obj\n     */\n    this.addOrUpdate = function (obj) {\n        if (!this.update(obj)) {\n            this.add(obj);\n        }\n    };\n\n    /**\n     * Update an object in the store\n     * @param obj\n     * @returns boolean true if added\n     */\n    this.update = function (obj) {\n        var existing = this.find(obj[indexKey]);\n        if (typeof existing != 'undefined') {\n            objects[objects.indexOf(existing)] = obj;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Notify about change\n     */\n    this.changed = function () {\n        flux._changed(namespace);\n    };\n    \n};\n\nmodule.exports = Store;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/store.js\n ** module id = 6\n ** module chunks = 0\n **/","var EventCollector = function (namespace, eventHub) {\n\n    /**\n     * Notify the event collector something happened\n     * @param eventName\n     * @param data\n     */\n    this.dispatch = function (eventName, data) {\n        eventHub.dispatch(namespace, eventName, data);\n    };\n\n    /**\n     * Dispatch for a certain namespace, only for advanced implementations, normally your event collector\n     * is chosen specifically for you command collection\n     * @param namespace\n     * @param eventName\n     * @param data\n     */\n    this.dispatchForNamespace = function (namespace, eventName, data) {\n        eventHub.dispatch(namespace, eventName, data);\n    }\n};\n\nmodule.exports = EventCollector;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/event_collector.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"fluxxy.js"}